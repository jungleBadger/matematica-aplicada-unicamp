<template>
  <section class="slide-container">
    <h2 class="slide-title">√çNDICES VETORIAIS (ANN)</h2>

    <div class="cards-container">
      <!-- Card 1: Por que ANN -->
      <div class="card">
        <div class="icon" aria-hidden="true">‚ö°</div>
        <h3>Por que usar</h3>
        <ul>
          <li class="fragment" data-fragment-index="1">
            <b>Escala:</b> busca exata √© O(N); ANN traz <b>lat√™ncia est√°vel</b> em milh√µes de vetores.
          </li>
          <li class="fragment" data-fragment-index="2">
            <b>Trade-off precis√£o √ó desempenho:</b> tune de <i>recall</i> vs. tempo/custo.
          </li>
          <li class="fragment" data-fragment-index="3">
            <b>Produ√ß√£o:</b> suporte a <i>top-k</i>, filtros, atualiza√ß√µes e particionamento.
          </li>
        </ul>
      </div>

      <!-- Card 2: Estruturas -->
      <div class="card">
        <div class="icon" aria-hidden="true">üß©</div>
        <h3>Estruturas principais</h3>
        <ul>
          <li class="fragment" data-fragment-index="4">
            <b>HNSW</b> (grafo hier√°rquico): √≥timo <i>recall</i>, busca <b>logar√≠tmica</b>, custo maior de mem√≥ria.
          </li>
          <li class="fragment" data-fragment-index="5">
            <b>IVF</b> (coarse quantization): divide em <i>clusters</i> e busca s√≥ nos mais pr√≥ximos.
          </li>
          <li class="fragment" data-fragment-index="6">
            <b>PQ/OPQ</b> (product quantization): <b>compress√£o</b> agressiva com perda controlada.
          </li>
          <li class="fragment" data-fragment-index="7">
            Combina√ß√µes: <b>IVF-PQ</b>, <b>HNSW+PQ</b> para equilibrar mem√≥ria/lat√™ncia.
          </li>
        </ul>
      </div>
    </div>
  </section>
</template>

<script setup>
defineOptions({ name: "SectionVectorIndex" });
</script>
